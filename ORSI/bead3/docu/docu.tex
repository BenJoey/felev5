\documentclass[12pt]{article}

\usepackage[a4paper,
inner = 15mm,
outer = 15mm,
top = 15mm,
bottom = 15mm]{geometry}

\usepackage{lmodern}
\usepackage[magyar]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{epstopdf}
\usepackage{setspace}
\usepackage[nottoc,numbib]{tocbibind}
\usepackage{setspace}

%%Note: Azért van tele sortörésekkel mert triggereli az OCD-met ha egy egész bekezdés egy sorba van :D

\makeatletter
\renewcommand*\env@matrix[1][c]{\hskip -\arraycolsep
	\let\@ifnextchar\new@ifnextchar
	\array{*\c@MaxMatrixCols #1}}
\makeatother

\setstretch{1.2}
\begin{document}
\def\br{\\[0.2cm]}
\begin{titlepage}
	\vspace*{0cm}
	\centering
	\begin{tabular}{cp{1cm}c}
		\begin{minipage}{4cm}
			\vspace{0pt}
			\includegraphics[width=1\textwidth]{elte_cimer}
		\end{minipage} & &
		\begin{minipage}{7cm}
			\vspace{0pt}Eötvös Loránd Tudományegyetem \vspace{10pt} \newline
			Informatikai Kar \vspace{10pt} \newline
			Programozási Nyelvek és Fordítóprogramok Tanszék
		\end{minipage}
	\end{tabular}
	
	\vspace*{0.2cm}
	\rule{\textwidth}{1pt}
	
	\vspace*{3cm}
	{\Huge Osztott rendszerek specifikációja és implementációja }
	
	\vspace*{0.5cm}
	{\normalsize IP-08bORSIG}
	
	\vspace{2cm}
	{\huge Dokumentáció a 3. beadandóhoz}
	
	\vspace*{5cm}
	
	{\large \verb|Bauer Bence| }
	
	{\large \verb|JPSMA3| }
		
	
	\vfill
	
	\vspace*{1cm}
	2018. november 27.
\end{titlepage}
\thispagestyle{empty}
\begin{center}
	\colorbox{lightgray}{{\large JPSMA3} \hspace{4.3cm} {\large ORSI 3. beadandó} \hspace{5.7cm} \thepage}
\end{center}
\section{Feladat}

%%Csak a feladat "lényegi" részét másoltam ki a beadból
%%A magyarázós részeket, segítségeket és megkötéseket nem
%%De ha kellenek azok is akkor újra beküldöm és bemásolom az egészet :)

Az egyik bemeneti fájlban \textit{data.txt} \textbf{N} darab gyakornoki jelentkezéshez tartozó
információ olvasható, melyak alapján ki kell szűrni, hogy összesen hány kompetens jelentkező
van a rengeteg beérkezett pályázat között.\br
\textit{data.txt} felépítése:

A fájl első sorában az \textbf{N} szám jelzi, hogy hány adatot olvasunk (ahol \textbf{N} egy nemnegatív egész szám).
A sorokban olvasható adatok függőleges vonal karakterrel (|) karakterrel vannak elválasztva egymástól.
Feltehetjük, hogy a | csak tagolási karakterként fordul elő egy-egy sorban, minden sor
helyesen van kitöltve, és pontosan annyi adat található a fájlban, amennyi az első sorban
olvasható, és nem található benne olyan sor, ahol kevesebb adat lenne megadva, vagy más módon
eltérne az elvárttól.

Adott egy másik fájl is \textit{filters.txt}, melyben összesen 7 különböző filter található.\\
\textit{filters.txt} felépítése:

A fájlban soronként egy filterhez tartozó adat olvasható. A három egész számú adatot
leszámítva a többiben | karakter szeparálja az információkat (pl. a képkiterjesztések sora
lehet: .png|.jpg|.jpeg) Feltehető, hogy minden sorban van értelmes és releváns adat (tehát
van elfogadott domain, meghirdetett állás, elvárt skill, elfogadott képformátum)

A beolvasott adatok alapján egy olyan adatcsatorna tételére visszavezetett megoldást kell
implementálni, mely beolvassa az inputadatokat, és az adatcsatorna egy-egy belső függvényének
egy-egy filtert megfeleltetve az inputadatokat végigfuttatja az összes szűrőn, majd kiírja az
\textit{output.txt} fájlba az adatokból azokat az e-mail címeket, akikhez tartozó
jelentkezésen az összes szűrő triggerelt.

\section{Felhasználói dokumentáció}
%%No idea what to write here :(

\subsection{Rendszer-követelmények, telepítés}

A programunk több platformon is futtatható, dinamikus függősége nincsen, bármelyik, manapság
használt PC-n működik. Külön telepíteni nem szükséges, elég a futtatható állományt elhelyezni
a számítógépen.

\subsection{A program használata}

A program használata egyszerű, külön paramétereket nem vár, így intézőből is indítható. A
futtatható állomány mellett kell elhelyezni az \textit{input.txt} valamint egy 
\textit{filters.txt} nevű fájlt, mely a bemeneti és a filterezési
adatokat tartalmazza, a fenti specifikációnak megfelelően. Figyeljünk az ebben található
adatok helyességére és megfelelő tagolására, mivel az alkalmazás külön ellenőrzést nem végez
erre vonatkozóan. A futás során az alkalmazás mellett található \textit{output.txt} fájl
tartalmazza a kapott eredményt, ami az összes filternek megfelelő jelentkezők email címei.

\newpage
\thispagestyle{empty}
\begin{center}
	\colorbox{lightgray}{{\large JPSMA3} \hspace{4.3cm} {\large ORSI 3. beadandó} \hspace{5.7cm} \thepage}
\end{center}

\section{Fejlesztői dokumentáció}

\subsection{Megoldási mód}
A feladatot az adatcsatorna tételére visszavezetve oldjuk meg.\\
A visszavezetésben az $n$ az input fájl első sorában lévő szám. Az adatcsatorna ($F(d)$) a
teljes filterezési folyamat míg a csatorna feldolgozási pontjait egy-egy filter függyvénynek
feleltetjük meg.\br
$
\begin{matrix}[l]
	n & \rightsquigarrow & \textbf{N} \\
	F(d) & \rightsquigarrow & d\text{ jelentkező megfelel-e az összes filternek} \\
	f_i & \rightsquigarrow  & i\text{-edik filter függyvény}
\end{matrix}
$\br
A kódot 2 részre lehet bontani, egy fő- és több alfolyamatra. A fő folyamat a \verb|main()|
függvény, mely először beolvassa a filtereket és azokkal elindítja az adatcsatorna működését
(alfolyamatok), majd beolvassa a jelentkezők adatait melyeket azután egyből felrak az első csatornára.\br
Egy alfolyamat levesz a csatornáról egy jelentkezőt és, ha a jelentkező az előtte lévő
csatornák filtereinek megfelelt akkor megvizsgálja a neki kiosztott filterre, amennyiben
egy korábbi filteren megbukott úgy csak továbbküldi az adatot.

\subsection{Implementáció}
A csatornákat egy \verb|Pipe<T>| típussal reprezentáljuk mely \verb|T template| paraméterként
megkapja, hogy milyen típusú adatok fognak áthaladni a csatornán.
A jelentkezők adainak csatornákon való küldéséhez egy \verb|Candidate| típust hozunk létre, 
melynek adattagjai az inputfájlban szereplő adatok és egy \verb|boolean| változó mely jelzi,
hogy az eddigi filtereknek megfelelt-e, konstruktora meg egy az inputfájl specifikációjának
megfelelő sort kap és az alapján tölti fel az adattagokat. Mivel egy csatorna nem tér vissza
értékkel hanem a kapott értéket továbbküldi így \verb|std::thread| típussal meg tudjuk
valósítani az alfolyamatokat, melyeket a filter sorának beolvasása után elindítunk
a következő paraméterekkel: a filterező függvény neve, előző és következő csatorna, és
jelentkezők száma (\textbf{N}). Egy alfolyamat terminál ha \textbf{N} darab adatot feldolgozott.
A \verb|Pipe<T>| típus reprezentációja a \verb|pipe.hpp| header fájlban van, míg a kód többi
része a \verb|crippling_depression.cpp| forrásfájlban található.

\subsection{Fordítás menete}
A programunk forráskódját a \verb|crippling_depression.cpp| fájl tartalmazza. A fordításhoz
elengedhetetlen egy \verb|C++11| szabványt támogató fordítóprogram a rendszeren. Ehhez
használhatjuk az \textit{MSVC}, \textit{g++} és \textit{clang} bármelyikét. A fordítás menete
(4.9.2-es verziójú g++ használata esetén) a következő: \verb|'g++ crippling_depression.cpp -std=c++11'|
. A speciális, \verb|-std=c++11| kapcsoló azért szükséges, mert alapértelmezés
szerint ez a verziójú fordítóprogram még a régi, C++98-as szabványt követi, melyben a
felhasznált nyelvi elemek még nem voltak jelen.

\newpage
\thispagestyle{empty}
\begin{center}
	\colorbox{lightgray}{{\large JPSMA3} \hspace{4.3cm} {\large ORSI 3. beadandó} \hspace{5.7cm} \thepage}
\end{center}

\subsection{Tesztelés}
A program tesztelése során különböző méretű bemeneti fájlokat generáltam. Az így kapott
fájlok mindig a specifikációnak megfelelően, az átlagostól a szélsőséges esetekig terjedtek.
A programom minden esetben a tőle elvárt kimenetet állította elő, így a tesztesetek alapján
helyesnek gondolhatjuk a működését.\br
A számítógépemben található 4 magból 3-at kikapcsolva, (időben) szekvenciális lefutást tudtam 
előállítani, így egy átlagos méretű fájl esetében (40-50 jelentkező) a futási idő $\sim$17 ms
körüli volt. A magokat sorban visszakapcsolva ez az idő egészen $\sim$5 ms-ig csökkent,
így megállapíthatjuk, hogy a párhuzamosított program tényleg gyorsabban futott, mint a
szekvenciális változata (Intel i7-6700K processzorral).
\end{document}